# SCI dmin JAX-TensorFlow-C++ Pipeline

![Python](https://img.shields.io/badge/Python-3.8+-blue.svg)
![JAX](https://img.shields.io/badge/JAX-latest-orange.svg)
![TensorFlow](https://img.shields.io/badge/TensorFlow-2.x-ff6f00.svg)
![C++](https://img.shields.io/badge/C++-17-blue.svg)

Compute analytical gradients and Hessians of the minimum distance function `dmin` using JAX automatic differentiation, with seamless C++ integration via TensorFlow SavedModel.

## Problem

Given 12 coordinates representing two curved beam segments, compute:

- **Function**: `dmin(x)` - minimum distance between beam arcs
- **Gradient**: `∇dmin(x)` - 12D sensitivity vector
- **Hessian**: `H_dmin(x)` - 12×12 curvature matrix

**Input**: `x = [a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, b0_x, b0_y, b1_x, b1_y, b2_x, b2_y]`

## Key Features

- ⚡ **Exact derivatives** via JAX automatic differentiation
- 🔬 **Validated** against finite differences (~10⁻⁵ accuracy)  
- 🚀 **Fast** JIT-compiled computation
- 🔄 **JAX → TensorFlow → C++** complete pipeline
- 📊 **Statistical validation** over 1000+ random configurations

## Installation and Setup

### Python Dependencies
```bash
pip install jax tensorflow numpy matplotlib
```

### C++ Dependencies
- TensorFlow C++ library (built from source)
- CMake >= 3.10
- C++17 compatible compiler

Update TensorFlow paths in `CMakeLists.txt`:
```cmake
set(TF_SOURCE_DIR "/path/to/tensorflow")
set(TF_LIB_DIR "/path/to/tensorflow/libs")
```

## How to Run

### Step 1: Python - Generate Model and Validate
```bash
python contact_geometry.py
```
This will:
- Validate gradients/Hessians against finite differences
- Export TensorFlow SavedModel to `exported_model/`
- Save Python results to `py_grad.txt` and `py_hess.txt`

### Step 2: C++ - Load Model and Compute
```bash
mkdir build && cd build
cmake ..
make
make run
```
This will:
- Load the exported TensorFlow model
- Read coordinates from `../x.txt`
- Compute same gradients/Hessians in C++
- Save C++ results to `../cpp_grad.txt` and `../cpp_hess.txt`

### Step 3: Compare Results
```bash
diff py_grad.txt cpp_grad.txt
diff py_hess.txt cpp_hess.txt
```
Should show no differences (or tiny numerical differences)

## Testing with Custom Data

### Input Format (`x.txt`)
The input file contains 12 coordinates representing two 3-node beam segments:
```
a0_x a0_y a1_x a1_y a2_x a2_y b0_x b0_y b1_x b1_y b2_x b2_y
```

Where:
- `a0, a1, a2`: Three consecutive nodes defining beam A
- `b0, b1, b2`: Three consecutive nodes defining beam B

### Example Test Cases

**Straight beams:**
```
-1.0 0.0  0.0 0.0  1.0 0.0  -1.0 2.0  0.0 2.0  1.0 2.0
```

**Curved beams:**
```
-1.0 0.0  0.0 0.0  0.5 0.866  0.0 1.5  1.0 1.5  1.5 2.0
```

**Close contact:**
```
-1.0 0.0  0.0 0.0  1.0 0.0  -1.0 0.1  0.0 0.1  1.0 0.1
```

### How to Test Different Configurations

1. **Modify `x.txt`** with your desired coordinates
2. **Run Python**: `python contact_geometry.py` 
3. **Run C++**: `cd build && make run`
4. **Check results**: Compare `py_grad.txt` and `cpp_grad.txt`

The program will compute:
- Minimum distance between the two curved beam arcs
- 12D gradient vector (sensitivity of distance to each coordinate)
- 12×12 Hessian matrix (second-order sensitivity information)

## JAX to C++ Pipeline

```
JAX Function (dmin) → jax2tf.convert → TensorFlow SavedModel → C++ TensorFlow API → Same Results
```

1. **JAX**: Define `dmin` with automatic differentiation
2. **Export**: Convert to TensorFlow SavedModel via `jax2tf`
3. **Load**: Import in C++ using TensorFlow C++ API
4. **Validate**: Compare Python vs C++ results

## Algorithm Overview

1. **Contact parameters**: Extract 5D representation `[x, y, ψ, κ₁, κ₂]` from 6 nodes
2. **Osculating circles**: Approximate curved segments as circular arcs  
3. **Arc sampling**: Discretize each arc into 300 points
4. **Distance computation**: Find minimum over all point pairs
5. **Auto-differentiation**: JAX computes exact `∇dmin` and `H_dmin`

## Files in Repository

- `contact_geometry.py` - Main JAX implementation with validation
- `main.cpp` - C++ TensorFlow integration
- `CMakeLists.txt` - Build configuration  
- `x.txt` - Input coordinates (12 values) - **modify this to test different cases**

## Generated Files (after running)

- `exported_model/` - TensorFlow SavedModel (generated by Python)
- `py_grad.txt`, `py_hess.txt` - Python computation results
- `cpp_grad.txt`, `cpp_hess.txt` - C++ computation results
- `single_compare.png` - Gradient/Hessian validation plot
- `err_hist_log.png` - Error distribution histogram

## Applications

- **Contact mechanics**: Beam-to-beam interaction analysis
- **Optimization**: Newton's method with Hessian information
- **Sensitivity analysis**: Parameter influence on `dmin`
- **Real-time simulation**: Fast C++ inference for interactive applications

## Usage Example

```python
# Python: Compute dmin derivatives
x = np.array([...])  # 12D coordinate vector
grad, hess = grad_and_hess(x)
print(f"Gradient shape: {grad.shape}")    # (12,)
print(f"Hessian shape: {hess.shape}")     # (12, 12)
```

```cpp
// C++: Load and run TensorFlow model
auto outputs = session->Run({input}, {"grad", "hess"});
auto gradient = outputs[0].flat<float>();
auto hessian = outputs[1].matrix<float>();
```

## Citation

```bibtex
@software{sci_dmin_jax_cpp,
  title = {SCI dmin JAX-TensorFlow-C++ Pipeline},
  author = {SCI Lab},
  year = {2025},
  url = {https://github.com/Jinying2/SCI_dmin-jax-tensorflow-cpp}
}
```

## Acknowledgments

This work is based on the contact geometry implementation from:
- Professor M. Khalid Jawed, "Tutorial - Contact in Beams using JACREV"
